## Monkey Patching

You can attach a monkey patch to each table. A monkey patch is a regular node module with the
following functions exported.

### exports['udf']

This function must return an object of user-defined functions. You can use user-defined functions to
extend `where` clauses of `select` statements.

    exports['udf'] = {
        'contains' : function(arg) {
            return {
                operator: 'CONTAINS',
                exprType: 'KeywordLogicalExpression',
                operandType: 'TokenOperand',
                operand: arg[0].value
            };
        },

        'blendBy' : function(percentage) {
            return {
                name: 'ITEM_FORMAT',
                namespace: 'ItemDictionary',
                property: [
                    {
                        name: 'isUsedForIntermingle',
                        value: 'true'
                    }
                ],
                auctionPercentage : percentage
            }
        }
    }

This exports two user-defined functions `contains` and `blendBy`. Here is a `select` statement that
uses a user defined function.

    select mapping[0].fieldValue.value.text from ebay.internal.finditems where
        contains('mini cooper')

This statement causes the engine to invoke `contains` with arg `mini cooper`.

Each user defined function must return an object containing names and values to prepare the
request.

## exports['validate param']

This function can valiate a param supplied from one of the inputs (statement, params, headers or
defaults).

    exports['validate param'] = function(statement, param, value) {
        switch(param) {
            case 'duration' :
                return !isNaN (value - 0)
            default:
                return true;
        }
    }

## exports['patch uri']

This function can introspect the URI of the outgoing request, and return a modified version if
necessary.

    exports['patch uri'] = function(args) {
        var statement = args.statement, uri = args.uri, params = args.params, count = 0;
        uri.setParam('paginationInput.pageNumber', statement.offset / statement.limit);
        uri.removeEmptyParams();

        count = 0
        if(params.FreeShippingOnly) {
            uri.addParam("itemFilter({count}).name", 'FreeShippingOnly');
            uri.addParam("itemFilter({count}).value", c.rhs.value);
            count++;
        }
        if(params.MinPrice) {
            uri.addParam("itemFilter({count}).name", 'MinPrice');
            uri.addParam("itemFilter({count}).value", c.rhs.value);
            count++;
        }
    }

## exports['patch headers']

This function can introspect and return updated request headers.

    exports['patch headers'] = function(args) {
        var statement = args.statement, uri = args.uri, params = args.params,
            headers = args.headers;

        ..

        return headers;
    }

## exports['patch status']

This function can introspect the response body and indicate if it is an error.

    // args contains status, headers, body
    exports['patch status'] = function(args) {
        var json = args.body;
        if(json && ((json.ack === 'Failure') ||
            json.errors)) {
            return 400;
        }
        else {
            return 200;
        }
    }

## exports['patch mediaType']

This function can override response media type.

    // args contains status, headers, body
    exports['patch mediaType'] = function(args) {
        return 'application/json';
    }

