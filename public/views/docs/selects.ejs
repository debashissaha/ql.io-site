<div class="breadcrumb"><a href="/docs">/docs</a></div>

<h1>Selects</h1>

<p>TODO: add a note format conversion to JSON.</p>

<p>TODO: add a note about XML namespaces.</p>


<p>TODO.</p>


<p>When you specify list of fields in the columns clause of a <code>select</code> statement, ql.io returns the
results in the form of a table - with each row containing the selected fields. For instance, the
query below return a table with each row containing three fields.</p>

<pre class="brush: sql">select title, itemId, primaryCategory.categoryName,
     sellingStatus.currentPrice from ebay.finding.items where keywords='iPhone'
</pre>

<p>A sample result set is below.</p>

<pre class="brush: js">
[
  [
    "Apple iPhone 4 (32GB) Black AT&amp;T b",
    "390352995399",
    "Cell Phones&amp;Smartphones",
    {
      "currencyId": "USD",
      "$t": "379.99"
    }
  ],
  [
    "Apple iPhone 4 (Latest Model) - 16GB - Black (AT&amp;T) Smartphone",
    "270828638551",
    "Cell Phones&amp;Smartphones",
    {
      "currencyId": "USD",
      "$t": "315.0"
    }
  ],
  ...
]
</pre>

<p>While this is a compact way getting the data you need, you need to refer to the selected columns to
know which element in a row refers to which field. You can optionally use column aliases to annotate
each field with a name.</p>

<pre class="brush: sql">
select title as title, itemId as id, primaryCategory.categoryName as cat,
       sellingStatus.currentPrice as price
from ebay.finding.items
where keywords='iPhone'
</pre>

<p>This will change the above result set to</p>

<pre class="brush: js">[
  {
    "title": "Apple iPhone 4 (32GB) Black AT&amp;T b",
    "id": "390352995399",
    "cat": "Cell Phones&amp;Smartphones",
    "price": {
      "currencyId": "USD",
      "$t": "379.99"
    }
  },
  {
    "title": "Apple iPhone 4 (Latest Model) - 16GB - Black (AT&amp;T) Smartphone",
    "id": "270828638551",
    "cat": "Cell Phones&amp;Smartphones",
    "price": {
      "currencyId": "USD",
      "$t": "315.0"
    }
  },
  ...
}
</pre>

<p>which is usually much more convenient to use.</p>

<p>With respect to stadard SQL, note the following differences:</p>

<blockquote>
<ul>
<li>Each alias must use 'as'. In SQL, 'as' is optional, but in ql.io 'as' is not optional.</li>
<li>When you decide to use aliases, use alias names for all the selected fields. If not, ql.io will
return an error.</li>
</ul>
</blockquote>
<p>Apart from annotating fields in result sets, column aliases let you join result sets on the fly.</p>


<div class="breadcrumb"><a href="/docs">/docs</a></div>

<h1>How to Use Joins</h1>

<p>You can use joins in statements to join data from two HTTP resources at a time by using a join condition. Here is an example.</p>
<pre class="brush: sql">
select e.Title, e.ItemID, g.geometry.location
from ebay.shopping.item as e, google.geocode as g
where e.itemId = 250894819626
  and g.address = e.Location
</pre>

<p>This statement combines two HTTP resources via the join condition <code>g.address = e.Location</code> resulting in a resultset like the following.</p>

<pre class="brush: js">
[
  [
    "Fun Minis - Springtime Sheep - Set of 50",
    "250894819626",
    {
      "lat": 37.7749295,
      "lng": -122.4194155
    }
  ]
]
</pre>

<p>Note the following differences from SQL:</p>

<ul>
<li>The <code>from</code> clause can not contain more than two tables. If you need to join from more than two, you can write multiple <code>select</code> statements each containing a join, and then do further joins on the results by using column aliases.</li>
<li>Tables in the <code>from</code> clause must be aliased using <code>as</code>.</li>
<li>The tables in the <code>from</code> clause must be ordered in the order of dependencies. In the above example, <code>ebay.shopping.item</code> provides data for <code>google.geocode</code> and hence must be listed first in the <code>from</code> clause.</li>
</ul>

<p>You can shape the response of this query by using column aliasing.</p>

<pre class="brush: sql">
select e.Title as title, e.ItemID as id, g.geometry.location as latng
from ebay.shopping.item as e, google.geocode as g
where e.itemId = 250894819626
  and g.address = e.Location
</pre>

<p>which results in</p>

<pre class="brush: js">
  {
    "title": "Fun Minis - Springtime Sheep - Set of 50",
    "id": "250894819626",
    "latng": {
      "lat": 44.8363889,
      "lng": 15.7580556
    }
  }
]
</pre>

<p>Here is another example.</p>

<pre class="brush: sql">
itemId = select itemId from ebay.finding.items where keywords = 'ferrari' limit 1;
item = select * from ebay.shopping.singleitem where itemId = '{itemId}';
tradingItem = select * from ebay.trading.getitem where itemId = '{itemId}';
return select i.BidCount as bids, ti.ListingDetails as details from item as i, tradingItem as ti where i.ItemID = ti.ItemID;
</pre>

<p>With the <code>return</code> statement joining <code>item</code> and <code>tradingItem</code>, you can expect a result set like the
following:</p>

<pre class="brush: js">
[
  {
    "bids": 8,
    "details": {
      "Adult": "false",
      "BindingAuction": "false",
      "CheckoutEnabled": "true",
      "ConvertedBuyItNowPrice": {
        "currencyID": "USD",
        "$t": "45000.0"
      },
      "ConvertedStartPrice": {
        "currencyID": "USD",
        "$t": "20000.0"
      },
      "HasReservePrice": "true",
      "StartTime": "2011-09-29T18:42:27.000Z",
      "EndTime": "2011-10-06T18:42:27.000Z",
      "ViewItemURL": "http://www.ebay.com/itm/2000-Ferrari-456-MGTA-RESERVE-LOWERED-456MGTA-456M-low-miles-Tubi-1-Owner-/300604864667",
      "HasUnansweredQuestions": "true",
      "HasPublicMessages": "false",
      "ViewItemURLForNaturalSearch": "http://www.ebay.com/itm/2000-Ferrari-456-MGTA-RESERVE-LOWERED-456MGTA-456M-low-miles-Tubi-1-Owner-/300604864667"
    }
  }
]
</pre>
