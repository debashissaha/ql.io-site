<h1>Language Overview</h1>
  
<p>ql.io's core consists of a domain-specific procedural-style language based on SQL and JSON. The
language does not conform to SQL, but it borrows several concepts from it to keep the language
familiar, and extends it to apply to HTTP APIs. This language currently has the following
capabilities:</p>

<ul>
    <li>Mapping HTTP resources into tables using a <code>create table</code> statement for select,
    update, insert and delete operations</li>

    <li>JSON objects</li>

    <li>Assignment of results of statements or objects to variables</li>

    <li>Projections of assignments</li>

    <li>Variable references in statements and objects</li>

    <li>Return statements</li>

    <li>Routes to execute stored scripts</li>
</ul>

<p>A ql script is a set of statements and comments. Statements must be declared in the order of
dependencies.</p>

<blockquote>
    There is no normative specification of the language yet. For now see <a
    href="/docs/reference/ql">railroad diagrams</a> for details of the currently implemented syntax.
</blockquote>

<p>Comments are single-line, and start with <code>--</code>.</p>

<pre class="brush: sql">
-- Welcome to ql.io
</pre>

<p>Assignments are optional for <code>create table</code> statements and scripts that have only one
statement. Otherwise, statements must be terminated with semi-colons. In single-statement scripts,
the return value of the script is implicit.</p>
  
<pre class="brush: sql">
select * from items
</pre>
  
<p>Statements can always be split into multiple lines by using carriage return. Multi-statement
scripts must always end with a <code>return</code> statement.</p>
  
<p>Assignment of statements and objects allow later statements in the script to refer to those
variables.</p>

<pre class="brush: sql">
items = select * from items;
return items;    
</pre>

<p>The assignment happens when the right hand side completes. The right hand side can be one of the
following:</p>
  
<ul>
    <li>A string, number, JSON object, array, <code>true</code>, <code>false</code>, or
    <code>null</code> - these are all values from <a href="http://json.org">JSON</a>.</li>

    <li><code>select</code> statement</li>
    <li><code>insert</code> statement</li>
    <li><code>update</code> statement (not supported yet)</li>
    <li><code>delete</code> statement (not supported yet)</li>
</ul>
  
<p>The predicate following a <code>return</code> can also be any of the above. This lets you
simplify the above script to the following single line script.</p>

<pre class="brush: sql">
return select * from items;
</pre>

<p>Since <code>return</code> is implicit in single statement scripts, this is the same as using the
following:</p>

<pre class="brush: sql">
select * from items
</pre>

<p>Selections and projects are not limited to tables - you can apply them to objects as well.</p>

<span class="try"><a href="/console?s=persons%20%3D%20%5B%0A%20%20%7B%22fname%22%3A%20%22John%22%2C%22lname%22%3A%20%22Doe%22%2C%20%22address%22%3A%20%7B%22city%22%3A%20%22San%20Francisco%22%7D%7D%2C%0A%20%20%7B%22fname%22%3A%20%22Jane%22%2C%22lname%22%3A%20%22Doe%22%2C%20%22address%22%3A%20%7B%22city%22%3A%20%22Bend%22%7D%7D%0A%5D%3B%0Areturn%20select%20woeid%20as%20woeid%2C%20centroid%20as%20centroid%20from%20yahoo.woe%20%0A%20%20where%20loc%20in%20(%22%7Bpersons.%24..city%7D%22)%3B">try me</a></span>
<pre class="brush: sql">
persons = [
  {"fname": "John","lname": "Doe", "address": {"city": "San Francisco"}},
  {"fname": "Jane","lname": "Doe", "address": {"city": "Bend"}}
];
return select woeid as woeid, centroid as centroid from yahoo.woe where
  loc in ("{persons.$..city}");
</pre>
  
<p>Execution of each statement can result in one or more HTTP requests. The table referenced in the
statement specifies how to make the HTTP request to a resource. Tables are declared using <a
href="/docs/create-table"><code>create table</code></a> statements. A <code>create table</code>
statement provides the following information:</p>
  
<ul>
    <li>A URI or a <a href="/docs/uri-template">URI template</a> of the HTTP resource.</li>

    <li>Optionally, default values for tokens in the URI template.</li>

    <li>Optionally, HTTP headers that must be included - these are in addition to some common
    headers like <code>Host</code>, <code>Content-Type</code>, <code>Content-Length</code>
    etc.</li>

    <li>Optionally, the template of the body for <code>POST</code>, <code>PUT</code>, and
    <code>PATCH</code> requests. For <code>application/x-www-urlform-encoded</code> bodies,
    templates are processed using the URI template syntax (i.e., tokens in curly braces). For other
    media types such as <code>application/json</code>, or <code>application/xml</code>, bodies are
    processed using <a href="http://mustache.github.com/">Mustache</a>.</li>

    <li>Optionally, a <a href="/docs/patches">monkey patch</a> - A monkey patch is a module that
    can be used to tweak requests and responses.</li>

    <li>Optionally, an <a href="/docs/auth">auth</a> module that can be used to authenticate a
    request.</li>
    
    <li>Optionally, a <a href="http://goessner.net/articles/JsonPath/">JSONPath</a>-styled
    expression to map a collection in the response to a result set.</li>
</ul>

<p>A <code>create table</code> maps each of <code>select</code>, <code>insert</code>,
<code>update</code> and <code>delete</code> statements into a HTTP method and a HTTP resource. The
most common mapping is to map a <code>select</code> statement to <code>GET</code>.</p>
  
<pre class="brush: sql">
create table geocoder
  on select get from "http://maps.googleapis.com/maps/api/geocode/json?address={address}&sensor=true"
  resultset "results";           
</pre>
 
<p>Since URIs for reads and writes could be different, a <code>create table</code> statement can map
each of <code>select</code>, <code>insert</code>, <code>update</code>, and <code>delete</code> to a
different HTTP resource with a different method.</p>

<pre class="brush: sql">
create table bitly.shorten
  on insert get from "http://api.bitly.com/v3/shorten?login={^login}&apiKey={^apikey}&longUrl={^longUrl}&format={format}"
    using defaults apikey = "{config.bitly.apikey}", login = "{config.bitly.login}", format = "json"
    using patch 'shorten.js'
    resultset 'data.url'
  on select get from "http://api.bitly.com/v3/expand?login={^login}&apiKey={^apikey}&shortUrl={^shortUrl}&format={format}"
    using defaults apikey = "{config.bitly.apikey}", login = "{config.bitly.login}", format = "json"
    using patch 'shorten.js'
    resultset 'data.expand'
</pre>

<p>The mapping between statement types and HTTP methods is arbitrary. the language does not impose
any particular mapping between SQL statement types and HTTP methods. For instance, the above script
maps an <code>insert into</code> statement to method <code>GET</code>.</p>

<p>The language uses <code>select</code> statements to select all (<code>*</code>) or particular
fields from HTTP resources. The naming of fields follow the <code>JSONPath</code> convention.</p>
  
<pre class="brush: sql">
select name.first, name.last, address.street from users where zip = 98074
</pre>  
  
<p>The <code>from</code> clause of a <code>select</code> statement can either refer to a table or an
object. See <a href="/selects">select</a> for complete syntax and examples.</p>
  
<p><code>insert into</code> statements are used to add data. </p>

<pre class="brush: sql">
insert into bitly.shorten (longUrl) values ('http://ql.io/docs')
</pre>

<blockquote>
    <code>update</code> and <code>delete</code> statements are supported yet.
</blockquote>

<p>See <a href="/inserts">insert</a> for complete syntax and examples.</p>

<p>Statements can depend on other statements by way of using <a href="/docs/variable-ref">variable
references</a>. A variable reference is a JSONPath-style token in curly braces
(<code>{token}</code>) in quoted (double or single) strings. </p>
  
<pre class="brush: sql">
name = "Bob";
details = select * from persons where name = "{name}";
accounts = select * from accounts where name = "{accounts}";
return {
  "name": "{name}",
  "details": "{details}",
  "accounts": "{accounts}"
}
</pre>

<p>This script has four statements - the first one assigns a string value to a variable, and the
second and third statements refer to that name. The fourth statement refers to all the three. </p>

<p>Variable references determine the order of executuion of statements in a script. The above
script leads to the following order.</p>

<img src="/images/docs/simple-orch.png" alt="Fork-join"/>

<p>You can also select from objects or tables.</p>

<pre class="brush: sql">
person = {
 "f": "Jon",
 "l": "Doe"
}
return select f from person;
</pre>

